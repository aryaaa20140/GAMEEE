<!doctype html>

<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Battlefront Blitz — War Shooter (ProGamer Build)</title>
<style>
:root{--bg:#070912;--panel:#081026;--neon:#ffcc00;--accent:#6ee7f8;--muted:#9aa4b2}
*{box-sizing:border-box;font-family:Inter, system-ui, Arial}
html,body{height:100%;margin:0;background:linear-gradient(180deg,#03040a 0%,#071226 100%);color:#eaf6ff}
.container{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:18px}
.card{width:1000px;max-width:98%;border-radius:12px;padding:14px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03);box-shadow:0 10px 40px rgba(2,6,20,0.8)}
.header{display:flex;align-items:center;justify-content:space-between;gap:12px}
.title{display:flex;gap:12px;align-items:center}
.logo{width:48px;height:48px;border-radius:8px;background:linear-gradient(135deg,#0b1220,#0f1b2b);display:flex;align-items:center;justify-content:center;border:1px solid rgba(255,204,0,0.06)}
h1{font-size:18px;margin:0;color:var(--neon)}
.lead{margin:2px 0 0;color:var(--muted);font-size:13px}
.controls{display:flex;gap:8px;align-items:center}
button{background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);padding:8px 12px;border-radius:8px;color:var(--accent);cursor:pointer}
.kbd{background:rgba(255,255,255,0.02);border-radius:6px;padding:6px 8px;border:1px solid rgba(255,255,255,0.03);font-size:13px;color:var(--muted)}
.main{display:flex;gap:12px;margin-top:12px}
.canvasWrap{flex:1}
canvas{width:820px;height:520px;background:linear-gradient(180deg,#071226 0%, #02030a 100%);display:block;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
.sidebar{width:230px;padding:10px;border-left:1px dashed rgba(255,255,255,0.02)}
.panel{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);margin-bottom:10px}
.hudRow{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
.stat{font-weight:700;color:var(--neon)}
.small{font-size:13px;color:var(--muted)}
.footer{display:flex;justify-content:space-between;align-items:center;margin-top:8px}
.help{font-size:13px;color:var(--muted)}
@media(max-width:980px){canvas{width:100%;height:420px}}
</style>
</head>
<body>
<div class="container">
  <div class="card">
    <div class="header">
      <div class="title">
        <div class="logo"><svg width="26" height="26" viewBox="0 0 24 24" fill="none"><path d="M2 12h20M12 2v20" stroke="#ffcc00" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"></path></svg></div>
        <div>
          <h1>Battlefront Blitz — War Shooter</h1>
          <div class="lead">Top-down arena combat — bullets, rockets, explosions, AI enemies, pickups, upgrades.</div>
        </div>
      </div>
      <div class="controls">
        <button id="start">Start</button>
        <button id="restart">Restart</button>
        <div class="kbd">WASD / Arrows = Move</div>
        <div class="kbd">Mouse = Aim</div>
        <div class="kbd">Left Click = Shoot</div>
      </div>
    </div><div class="main">
  <div class="canvasWrap">
    <canvas id="game" width="820" height="520"></canvas>
  </div>
  <div class="sidebar">
    <div class="panel">
      <div class="hudRow"><div class="small">Score</div><div id="score" class="stat">0</div></div>
      <div class="hudRow"><div class="small">Health</div><div id="hp" class="stat">100</div></div>
      <div class="hudRow"><div class="small">Wave</div><div id="wave" class="stat">0</div></div>
      <div class="hudRow"><div class="small">Armor</div><div id="armor" class="stat">0</div></div>
    </div>

    <div class="panel">
      <div class="small">Weapons</div>
      <ul id="weapons" class="small">
        <li>Rifle (default) — balanced</li>
        <li>Shotgun (press 2) — close range</li>
        <li>Rocket (press 3) — high damage, slow</li>
      </ul>
    </div>

    <div class="panel small">
      Pickups: <br>- Green = Health (+HP)<br>- Blue = Ammo / Rapid Fire <br>- Yellow = Armor
    </div>

    <div class="panel small">
      Tips: Aim with mouse. Use cover (map obstacles). Survive waves to earn upgrades.
    </div>
  </div>
</div>

<div class="footer">
  <div class="help">ProGamer Build — Single-file. Open in browser and play.</div>
  <div class="small">Want C++/SDL or PHP leaderboard? I can port it.</div>
</div>

  </div>
</div><script>
// Battlefront Blitz — Single-file top-down shooter
// Controls: WASD/Arrows move, mouse aim, left click shoot. Press 1/2/3 to switch weapons.
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const startBtn = document.getElementById('start');
  const restartBtn = document.getElementById('restart');
  const scoreEl = document.getElementById('score');
  const hpEl = document.getElementById('hp');
  const waveEl = document.getElementById('wave');
  const armorEl = document.getElementById('armor');

  let mouse = {x: W/2, y: H/2, down:false};
  canvas.addEventListener('mousemove', e => { const rect = canvas.getBoundingClientRect(); mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width); mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height); });
  canvas.addEventListener('mousedown', e => mouse.down = true);
  canvas.addEventListener('mouseup', e => mouse.down = false);

  const keys = {};
  window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
  window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

  function rnd(a,b){return Math.random()*(b-a)+a}
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

  class Particle{ constructor(x,y,color,life,rad){ this.x=x;this.y=y;this.vx=rnd(-2,2);this.vy=rnd(-2,2);this.life=life;this.color=color;this.r=rad||2;} update(){this.x+=this.vx;this.y+=this.vy;this.life--; } draw(){ if(this.life<=0) return; ctx.globalAlpha = clamp(this.life/30,0,1); ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill(); ctx.globalAlpha=1; }}

  class Bullet{ constructor(x,y,angle,speed,damage,owner,life=120){ this.x=x;this.y=y;this.vx=Math.cos(angle)*speed;this.vy=Math.sin(angle)*speed;this.r=3;this.damage=damage;this.owner=owner;this.life=life; } update(){ this.x+=this.vx;this.y+=this.vy; this.life--; } draw(){ ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fillStyle = this.owner==='player' ? 'rgba(180,220,255,0.95)' : 'rgba(255,160,120,0.95)'; ctx.fill(); }}

  class Rocket{ constructor(x,y,angle){ this.x=x;this.y=y;this.vx=Math.cos(angle)*4.2;this.vy=Math.sin(angle)*4.2;this.r=6;this.life=220; } update(){ this.x+=this.vx;this.y+=this.vy; this.vx *= 0.999; this.vy *= 0.999; this.life--; } draw(){ ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fillStyle='rgba(255,120,80,0.95)'; ctx.fill(); ctx.beginPath(); ctx.arc(this.x - this.vx*2, this.y - this.vy*2, 2,0,Math.PI*2); ctx.fillStyle='rgba(255,200,80,0.6)'; ctx.fill(); }}

  class Entity{ constructor(x,y){ this.x=x;this.y=y; } }

  class Player extends Entity{
    constructor(){ super(W/2,H/2); this.r=14; this.speed=3.2; this.health=100; this.maxHealth=100; this.armor=0; this.score=0; this.fireCooldown=0; this.weapon='rifle'; this.ammo={rifle:999,shotgun:60,rocket:6}; this.weaponData={rifle:{rate:8,spd:9,dmg:10}, shotgun:{rate:28,spd:8,dmg:8,pellets:6,spread:0.6}, rocket:{rate:80,spd:4,dmg:70}}; }
    update(){
      let dx = 0, dy=0; if(keys['w']||keys['arrowup']) dy-=1; if(keys['s']||keys['arrowdown']) dy+=1; if(keys['a']||keys['arrowleft']) dx-=1; if(keys['d']||keys['arrowright']) dx+=1; if(dx||dy){ const len = Math.hypot(dx,dy); this.x += (dx/len)*this.speed; this.y += (dy/len)*this.speed; }
      this.x = clamp(this.x, this.r, W - this.r); this.y = clamp(this.y, this.r, H - this.r);
      if(this.fireCooldown>0) this.fireCooldown--;
      // weapon switch
      if(keys['1']) this.weapon='rifle'; if(keys['2']) this.weapon='shotgun'; if(keys['3']) this.weapon='rocket';
      // auto shoot if mouse down
      if(mouse.down) this.tryShoot();
    }
    tryShoot(){ const wd = this.weaponData[this.weapon]; if(this.fireCooldown>0) return; if(this.ammo[this.weapon]<=0) return; const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
      if(this.weapon==='rifle'){ bullets.push(new Bullet(this.x + Math.cos(angle)*18, this.y + Math.sin(angle)*18, angle, wd.spd, wd.dmg, 'player')); this.fireCooldown = wd.rate; this.ammo.rifle--; }
      else if(this.weapon==='shotgun'){ for(let i=0;i<wd.pellets;i++){ const a = angle + (rnd(-wd.spread, wd.spread)); bullets.push(new Bullet(this.x + Math.cos(a)*18, this.y + Math.sin(a)*18, a, wd.spd * rnd(0.85,1.05), wd.dmg, 'player')); } this.fireCooldown = wd.rate; this.ammo.shotgun--; }
      else if(this.weapon==='rocket'){ rockets.push(new Rocket(this.x + Math.cos(angle)*18, this.y + Math.sin(angle)*18, angle)); this.fireCooldown = wd.rate; this.ammo.rocket--; }
    }
    draw(){ // player triangle pointing to mouse
      const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
      ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(angle);
      ctx.beginPath(); ctx.moveTo(18,0); ctx.lineTo(-14,10); ctx.lineTo(-14,-10); ctx.closePath(); ctx.fillStyle='rgba(100,200,255,0.12)'; ctx.fill(); ctx.strokeStyle='rgba(180,220,255,0.95)'; ctx.lineWidth=1.6; ctx.stroke(); ctx.restore();
    }
  }

  class Enemy extends Entity{
    constructor(x,y,level=1){ super(x,y); this.r = 12 + Math.min(12, level*2); this.speed = 0.7 + level*0.12; this.health = 18 + level*8; this.level = level; this.fireCooldown = rnd(30,120); this.type = level>4? 'tank':'grunt'; }
    update(){ const dx = player.x - this.x; const dy = player.y - this.y; const ang = Math.atan2(dy,dx); this.x += Math.cos(ang)*this.speed; this.y += Math.sin(ang)*this.speed; if(this.fireCooldown>0) this.fireCooldown--; if(this.fireCooldown<=0 && Math.random()<0.3){ bullets.push(new Bullet(this.x, this.y, ang, 4, 8, 'enemy')); this.fireCooldown = rnd(60,140); } }
    draw(){ ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fillStyle='rgba(255,110,110,0.08)'; ctx.fill(); ctx.strokeStyle='rgba(255,140,120,0.9)'; ctx.stroke(); }
  }

  class Pickup{ constructor(x,y,type){ this.x=x;this.y=y;this.type=type;this.r=8;this.life=900;} update(){ this.life--; } draw(){ ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); if(this.type==='health') ctx.fillStyle='rgba(90,255,120,0.95)'; else if(this.type==='ammo') ctx.fillStyle='rgba(120,180,255,0.95)'; else ctx.fillStyle='rgba(255,210,90,0.95)'; ctx.fill(); }}

  // world obstacles
  const obstacles = [];
  function makeObstacles(){ obstacles.length=0; // create random rectangles
    for(let i=0;i<8;i++){ const w=rnd(60,160), h=rnd(30,110); const x=rnd(40,W-40-w), y=rnd(40,H-40-h); obstacles.push({x,y,w,h}); }
  }

  let player, bullets=[], rockets=[], enemies=[], particles=[], pickups=[];
  let running=false, wave=0, spawnTimer=0;

  function reset(){ player = new Player(); bullets=[]; rockets=[]; enemies=[]; particles=[]; pickups=[]; wave=0; spawnTimer=0; makeObstacles(); updateHUD(); }

  function spawnWave(){ wave++; waveEl.textContent = wave; const count = Math.min(40, 4 + Math.floor(wave*1.7)); for(let i=0;i<count;i++){ const edge = Math.floor(rnd(0,4)); let x,y; if(edge===0){ x=rnd(-60,W+60); y=-60; } else if(edge===1){ x=rnd(-60,W+60); y=H+60; } else if(edge===2){ x=-60; y=rnd(-60,H+60); } else { x=W+60; y=rnd(-60,H+60); } const level = 1 + Math.floor(wave/3) + Math.floor(rnd(0,2)); enemies.push(new Enemy(x,y,level)); } }

  function updateHUD(){ scoreEl.textContent = Math.floor(player.score); hpEl.textContent = Math.max(0, Math.floor(player.health)); waveEl.textContent = wave; armorEl.textContent = player.armor; }

  function hitObstacle(x,y){ // returns true if point is inside obstacle
    for(const o of obstacles){ if(x>o.x && x<o.x+o.w && y>o.y && y<o.y+o.h) return true; } return false; }

  function explosion(x,y,power=20,color='orange'){ for(let i=0;i<Math.floor(power*1.4);i++){ particles.push(new Particle(x + rnd(-8,8), y + rnd(-8,8), color, 30 + Math.floor(rnd(0,40)), rnd(1,3))); } }

  function gameOver(){ running=false; ctx.save(); ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,W,H); ctx.fillStyle='white'; ctx.textAlign='center'; ctx.font='32px Inter, Arial'; ctx.fillText('YOU DIED', W/2, H/2 - 6); ctx.font='18px Inter, Arial'; ctx.fillText('Score: '+Math.floor(player.score)+'  —  Press Restart', W/2, H/2 + 24); ctx.restore(); }

  function update(){ if(!running) return; // physics & logic
    player.update();
    // bullets
    for(let i=bullets.length-1;i>=0;i--){ const b = bullets[i]; b.update(); // collisions
      // obstacles
      if(hitObstacle(b.x,b.y)){ explosion(b.x,b.y,6,'rgba(255,200,80,0.9)'); bullets.splice(i,1); continue; }
      // enemy hit
      if(b.owner==='player'){ for(let j=enemies.length-1;j>=0;j--){ const e = enemies[j]; const d = Math.hypot(b.x-e.x,b.y-e.y); if(d < e.r + b.r){ e.health -= b.damage; bullets.splice(i,1); particles.push(new Particle(b.x,b.y,'rgba(255,220,180,0.9)',20,2)); if(e.health<=0){ explosion(e.x,e.y,16,'rgba(255,140,80,0.9)'); player.score += 10 + e.level*6; if(Math.random()<0.25) pickups.push(new Pickup(e.x + rnd(-8,8), e.y + rnd(-8,8), Math.random()<0.5?'health':'ammo')); enemies.splice(j,1); } break; } } }
      // player hit by enemy bullets handled below
      if(b.life<=0 || b.x< -30 || b.x> W+30 || b.y< -30 || b.y> H+30) bullets.splice(i,1);
    }

    // rockets
    for(let i=rockets.length-1;i>=0;i--){ const r = rockets[i]; r.update(); if(hitObstacle(r.x,r.y)){ explosion(r.x,r.y,30,'rgba(255,120,80,0.95)'); rockets.splice(i,1); continue; }
      // enemy collision
      for(let j=enemies.length-1;j>=0;j--){ const e = enemies[j]; const d = Math.hypot(r.x-e.x,r.y-e.y); if(d < e.r + r.r + 6){ explosion(r.x,r.y,40,'rgba(255,120,80,0.95)'); // heavy damage to nearby enemies
            for(let k=enemies.length-1;k>=0;k--){ const e2=enemies[k]; const d2=Math.hypot(r.x-e2.x,r.y-e2.y); if(d2 < 80){ e2.health -= 40 * (1 - d2/100); if(e2.health<=0){ explosion(e2.x,e2.y,18,'rgba(255,140,100,0.9)'); player.score += 10 + e2.level*6; enemies.splice(k,1); } } }
            rockets.splice(i,1); break; } }
      if(r.life<=0) rockets.splice(i,1);
    }

    // enemy behavior and enemy bullets hitting player
    for(let i=enemies.length-1;i>=0;i--){ const e = enemies[i]; e.update(); // enemy collides with player
      const d = Math.hypot(player.x - e.x, player.y - e.y); if(d < e.r + player.r){ // melee contact
        player.health -= 8 + e.level*2; explosion(e.x,e.y,8,'rgba(255,120,100,0.6)'); enemies.splice(i,1); if(player.health<=0){ updateHUD(); gameOver(); return; } }
    }

    // enemy bullets hitting player
    for(let i=bullets.length-1;i>=0;i--){ const b = bullets[i]; if(b.owner==='enemy'){ const d = Math.hypot(b.x - player.x, b.y - player.y); if(d < b.r + player.r){ player.health -= b.damage - player.armor*0.2; particles.push(new Particle(player.x + rnd(-6,6), player.y + rnd(-6,6), 'rgba(255,80,80,0.95)',20,2)); bullets.splice(i,1); if(player.health<=0){ updateHUD(); gameOver(); return; } } } }

    // pickups collect
    for(let i=pickups.length-1;i>=0;i--){ const p=pickups[i]; p.update(); const d = Math.hypot(player.x - p.x, player.y - p.y); if(d < p.r + player.r){ if(p.type==='health'){ player.health = Math.min(player.maxHealth, player.health + 30); } else if(p.type==='ammo'){ player.ammo.rifle += 40; player.ammo.shotgun += 12; player.ammo.rocket += 1; } else { player.armor = Math.min(50, player.armor + 15); } pickups.splice(i,1); } }

    // particles
    for(let i=particles.length-1;i>=0;i--){ particles[i].update(); if(particles[i].life<=0) particles.splice(i,1); }

    // spawn waves
    if(enemies.length===0 && spawnTimer<=0){ spawnWave(); spawnTimer = 200; }
    if(spawnTimer>0) spawnTimer--;

    // incremental score
    player.score += 0.02;
    updateHUD();
  }

  function draw(){ // render loop
    ctx.clearRect(0,0,W,H);
    // background grid
    ctx.save(); ctx.globalAlpha=0.04; for(let gx=0;gx<W;gx+=32){ ctx.beginPath(); ctx.moveTo(gx,0); ctx.lineTo(gx,H); ctx.strokeStyle='white'; ctx.stroke(); } for(let gy=0;gy<H;gy+=32){ ctx.beginPath(); ctx.moveTo(0,gy); ctx.lineTo(W,gy); ctx.stroke(); } ctx.restore();

    // obstacles
    ctx.save(); ctx.fillStyle='rgba(8,12,18,0.8)'; for(const o of obstacles){ ctx.fillRect(o.x,o.y,o.w,o.h); ctx.strokeStyle='rgba(255,255,255,0.02)'; ctx.strokeRect(o.x,o.y,o.w,o.h); } ctx.restore();

    // pickups
    for(const p of pickups) p.draw();

    // bullets
    for(const b of bullets) b.draw();
    for(const r of rockets) r.draw();

    // enemies
    for(const e of enemies) e.draw();

    // player
    player.draw();

    // particles
    for(const p of particles) p.draw();

    // HUD crosshair
    ctx.beginPath(); ctx.arc(mouse.x, mouse.y, 6, 0, Math.PI*2); ctx.strokeStyle='rgba(200,230,255,0.9)'; ctx.stroke(); ctx.beginPath(); ctx.moveTo(mouse.x - 12, mouse.y); ctx.lineTo(mouse.x + 12, mouse.y); ctx.moveTo(mouse.x, mouse.y - 12); ctx.lineTo(mouse.x, mouse.y + 12); ctx.strokeStyle='rgba(120,200,255,0.45)'; ctx.stroke();

    // minimap small
    ctx.save(); ctx.globalAlpha=0.6; ctx.fillStyle='rgba(3,6,23,0.6)'; ctx.fillRect(W-150,10,140,100); ctx.restore(); ctx.fillStyle='white'; ctx.font='10px Inter,Arial'; ctx.fillText('Minimap', W-130, 22);
    ctx.save(); ctx.translate(W-150+10,32); ctx.scale(0.16,0.16); // draw simplified
    ctx.fillStyle='rgba(200,200,200,0.05)'; ctx.fillRect(0,0,W, H); // can't fully scale but ok
    ctx.restore();
  }

  function loop(){ update(); draw(); if(running) requestAnimationFrame(loop); }

  startBtn.addEventListener('click', ()=>{ if(running) return; reset(); running=true; loop(); });
  restartBtn.addEventListener('click', ()=>{ reset(); running=true; loop(); });

  // initial demo state
  (function intro(){ ctx.clearRect(0,0,W,H); ctx.fillStyle='#6EE7F8'; ctx.font='16px Inter, Arial'; ctx.textAlign='center'; ctx.fillText('Battlefront Blitz — Press Start to Play', W/2, H/2 - 6); ctx.font='12px Inter, Arial'; ctx.fillText('Controls: WASD Arrows to move — Mouse to aim — Left click to shoot', W/2, H/2 + 16); })();

})();
</script></body>
</html>
